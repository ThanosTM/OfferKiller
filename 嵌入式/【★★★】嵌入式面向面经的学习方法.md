## 1、嵌入式开发为什么选择C语言，而不是C++呢？
嵌入式软件一般需要着重考虑三个方面：性能、安全性、开发效率等；
#### 使用C语言具有以下优势：
- 出色的可移植性，便于向不同体系结构的软硬件平台中移植；
- 具有很高的运行效率：运行效率介于汇编与C++之间，同时又比汇编更具有开发效率；生成的目标代码量小，占用内存小，适合在小内存的嵌入式平台上运行；
- 能够直接访问硬件，并且操作系统内核都是用C原因来编写，在进行操作系统中的嵌入式开发时使用C语言非常兼容。

#### 同时C语言具有如下缺点：
- 代码可复用性差；
- 代码可扩展性差；
- 代码可维护性差；

#### 这就要求C语言开发者在编写C代码中尽量克服这些缺陷，具体做法可以学习Linux内核。

#### 过去认为嵌入式开发中C++具有以下缺陷：
- 执行效率低；
- 生成目标代码量大；
- 编程麻烦，学习成本高；

#### C++编程的优势
市场调查显示，嵌入式开发中C++语言使用比例在逐年增加，这是由于C++的逐年发展，以及嵌入式平台的资源越来越充足，C++带来的小幅性能损失与内存增大可以忽略；
- C++的不断版本更新，引入高级语言新的特性，使开发效率提升；


## 2、实时操作系统如何保证强实时性
实时操作系统与一般操作系统相比，最大的特色是“实时性”，这个实时性体现在：==如果有一个任务需要执行，实时操作系统会在较短时间内执行该任务，这个特性保证了各个任务的及时执行==。实时约束是从事件发生到系统响应之间的最长时间限制。RTOS中需要包含一个实时任务调度器，该调度器最大的不同是强调严格按照优先级分配CPU时间，时间片轮转也不是一个必选项。这是为了：
- 避免任务频繁切换导致CPU时间浪费；
- 在一些特殊场景中，保证重要的任务优先被执行。

实时操作系统的设计思路：
- 实时的事件处理机制：常规操作系统中按照FIFO调度消息队列，RTOS会提供基于优先级的处理方式，两个任务等待同一个信号量，会分配给优先级高的任务。
- ==提供内核级的优先级翻转处理方式==：对于类似信号量一类的API，都会提供抑制优先级翻转的机制，防止操作系统死锁。
- 减少粗粒度的锁和长期关中断的使用：非实时操作系统中，为了同步的需要，可能会长期关闭中断，例如收到一个外部中断时可能会在整个处理过程中关闭中断，可能会达到毫秒量级，这是RTOS无法接受的；相反，RTOS通常的做法是，将中断作为一个事件通知另外一个任务，中断处理程序中处理完关键数据之后立即打开中断，随后以一个高优先级任务的方式继续执行。
- 系统级服务也要保证实时性：例如文件操作，非实时系统可能会缓存用户请求，而不是将数据直接写入设备，但是实时系统中允许高优先级的任务优先写入数据，直到操作完成。这实际上可能会牺牲性能，但是实时系统关注的点在于整体的实时性而非某个点。
- 避免提供实时性不确定的API：多数实时系统不支持虚拟内存，主要原因是缺页中断会导致任务调度的不确定性增加，一次缺页中断的开销巨大，设计的代码很多，导致用户程序执行的不确定性增加。甚至地，极端情形下会禁用动态分配，保证系统运行不受到动态任务的变化所干扰。
- 提供针对实时系统调度的专用API：比如ARINC 653标准中就针对任务调度等作出了一系列的规定，同时定义了特定的API接口和API行为，这些API不同于POSIX API，这适用于航空设备上实时性要求极高的场景。
- 降低系统抖动：由于关中断等原因，操作系统调度器不会太精确地周期性调度，但是一个优秀的实时操作系统能够把调度器的抖动降低到微秒甚至百纳秒级。这对于例如x86这种天生抖动较大的架构而言尤为重要。
- 针对实时性设计的SMP和虚拟化技术：SMP场景的实时调度非常困难，涉及到了任务核间的迁移，多数RTOS的设计都不算优秀，但相较非实时系统已经有相当大的改观；同时RTOS的虚拟化能够从hypervisor层面提供虚拟机级别的实时调度。

随着设备性能的发展，其实很多系统都已经换成普通操作系统了，因为硬件性能的提升能够使非实时系统的延迟降低到一个可以接受的地步。但是在工业自动化、机器人、航空航天、军工等领域，仍然对RTOS有强烈需求。

## 3、如何将Linux系统改造成实时操作系统
linux windows本来是通用操作系统，不是实时操作系统，所以设计初是宏内核，本着公平的原则，虽然用户可以设计任务优先级，但操作系统会根据每个任务的运行时间，自动调整每个任务占用CPU的时间，这样使每个任务都能公平的占用cpu.

#### 制约Linux操作系统实时性的因素
- 进程调度：Linux提供符合POSIX标准的调度策略，其中默认的调度策略SCHED_OTHER虽然能够使进程公平地使用CPU和其他资源，但不能保证对时间要求严格或者高优先级进程先于低优先级进程执行；而所谓实时调度策略SCHED_FIFO 或SCHED_RR，Linux在用户态支持可抢占调度策略，但内核态不完全支持抢占式调度策略，因此运行在内核态的任务（系统调用和中断处理）无法被优先级更高的任务抢占。
- 内核抢占机制：运行在内核态的进程无法被抢占，因此当进程进入内核态运行时，实时任务必须等待系统调用返回后才能获得系统资源；在Linux2.6后，内核时可以配置为抢占式的：
1. PREEMPT_NONE：没有强制性的抢占，整体延时较低，但会偶尔出现一些较长的延时；
2. PREEMPT_VOLUNTARY：降低延时的第一阶段，会在内核代码的关键位置上放置额外的显式抢占点；
3. PREEMPT_DESKTOP：内核的任何地方都是可抢占的，临界区除外，适合软实时应用程序，例如音视频，但牺牲了整体吞吐率；

- 中断屏蔽：Linux在处理中断时都会关闭中断，因为这样更快、更安全地处理完自己的任务，但这时会错过更高优先级的实时进程中断，使得中断延时和调度延时增大；
- 时钟粒度粗糙：在Linux2.6内核中，时钟中断发生频率范围是50~1200Hz，周期不小于0.8ms，对于需要几十微秒的响应精度的应用来说显然不满足要求。而在嵌入式Linux系统中，为了提高整体吞吐率，时钟频率一般设置为100HZ或250HZ。另外，系统时钟负责软定时，当软定时器逐渐增多时会引起定时器冲突，增加系统负荷。
- 虚拟内存管理：虚拟内存使得进程可以运行在比实际内存空间大得多的虚拟空间中，但对于RTOS，频繁的页面换进换出会导致系统进程无法在规定时间完成；

#### 常用的实时Linux改造方案
###### 直接修改Linux内核源码
Linux的主线代码还不支持硬实时，为了开启硬实时功能需要对内核打补丁。该实时内核补丁是多方努力的成果，目的是为了降低Linux内核的延时，补丁网址：www.kernel.org/pub/linux/kernel/projects/rt/. 该项目添加了新的抢占模式：PREEMPT_RT实时抢占，使用可抢占的互斥量代替自旋锁，除了preempt_disable()保护的区域都能够被抢占。但是问题在于：难以保证实时进程的执行不会遭到非实时进程所进行的不可预测活动的干扰。

###### 双内核法
由于GPOS的代码复杂，更多的程序代码会导致更大的不确定性；双内核法是在同一硬件平台上采用两个相互配合，共同工作的核心，可以在Linux系统的最底层增加一层实时核心来实现，其中一个核心提供精确的实时多任务处理，一个提供复杂的非实时通用功能。本质在于将Linux内核作为一个普通进程在另一个内核上运行，关键改造部分是在Linux和中断控制器间增加了一层中断控制的仿真层，该中断仿真机制提供了一个标志用来记录Linux开关中断的情况；优点是可以做到硬实时，例如RTLinux/GPL.


